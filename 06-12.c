#define _CRT_SECURE_NO_WARNINGS
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

/*
Задача 06-12: Генерал танковых войск
Генерал танковых войск Петя из 8Б класса проснулся в это субботнее утро в приподнятом настроении.
Сегодня он и его верные братья по оружию нанесут решительный удар по Берлину, отомстят своим жалким недругам из 9В класса, добудут много золота и покроют себя славой.
И в этот раз никакие ничего не понимающие в тактике главнокомандующие-родители не прервут героическую операцию под предлогом того, что ночные наступления совершенно недопустимы.
К сожалению, Петя обнаружил, что один из родителей, недовольный тем, что успехи Пети вне поля сражения не дотягивают даже до звания рядового, сменил пароль от компьютера.
Рядом Петей была найдена бумажка с длинной строкой. Вспомнив все предыдущие пароли, он понял, что каждый новый является подстрокой данной строки. Прикинув время,
необходимое для проверки одного пароля, Петя теперь хочет подсчитать сколько вообще паролей возможно(то есть различных подстрок, включая пустую), чтобы понять, успеет
ли он к ночному наступлению. Разделите горе Пети и помогите ему.

Входные данные. Дана строка состоящая из маленьких латинских букв и длины не более, чем 2000 символов.

Выходные данные. Выведите единственное число — количество различных подстрок входной строки.
*/

typedef long long ll;

int dobavka(char* s)
{
	int n = strlen(s);
	int*z = (int*)calloc(n, sizeof(int));
	int maximum = 0;
	for (int i = 1, l = 0, r = 0; i < n; ++i)
	{
		if (i <= r) { z[i] = (r - i + 1 < z[i - l] ? r - i + 1 : z[i - l]); }
		while (i + z[i] < n && s[z[i]] == s[i + z[i]]) { ++z[i]; }
		if (i + z[i] - 1 > r) { l = i, r = i + z[i] - 1; }
		if (maximum < z[i]) { maximum = z[i]; }
	}
	free(z);
	return n - maximum;
}

int main(int argc, char** argv)
{
    char s[3002];
    fgets(s, 3000, stdin);
    int len = strlen(s);
    if (s[len - 1] == '\n') { len--; }
    int ans = 1;
	for (int i = 0; i < len; i++)
	{
		char* temp = (char*)malloc((i + 2) * sizeof(char));
		for (int j = i; j >= 0; j--)
		{
			temp[i - j] = s[j];
		}
		temp[i + 1] = '\0';
		ans += dobavka(temp);
		free(temp);
	}
	printf("%d\n", ans);
    return 0;
}
