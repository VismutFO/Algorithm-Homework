#define _CRT_SECURE_NO_WARNINGS
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

/*
Задача 04-9: Выравнивание абзаца
Дано натуральное число K и строка текста, состоящая из слов, отделенных пробелами.
Требуется разбить входную строку на строки длины K. В очередной строке должно быть выведено максимальное количество очередных слов входной строки,
которые целиком помещаются в строку длины K (при условии, что слова разделены хотя бы одним пробелом).
При этом, требуется каждую выходную строку отформатировать следующим образом. Необходимо, чтобы среднеквадратическое отклонение длин пробельных серий в каждой
такой строке было минимальным (пробельная серия - непрерывная последовательность пробелов между двумя словами). То есть, если в строке есть n пробельных серий
длины li и среднее арифметическое этих длин равно L, то среднее арифметическое величин (li - L)2 должно быть минимально для результирующей строки.

Если в строку входит больше одного слова, дополнять пробелами разрешается только промежутки между двумя словами. При возможности добавить пробел в несколько промежутков,
выбирать следует тот промежуток, который расположен ближе всего к началу строки. Если же только одно очередное слово входной строки входит в очередную выходную строку,
то необходимо вывести сначала это слово, а потом дополнить длину очередной выходной строки пробелами до K символов.

На стандартном потоке ввода в первой строке задано число K (K ≥ 1, K ≤ 106), во второй строке задана последовательность символов (строка) S, состоящая из пробелов
и букв латинского алфавита, признак окончания которой - символ перевода строки. Известно, что длина строки S ≤ 106. Строка состоит из слов, разделенных пробельными
символами (по одному пробелу между двумя словами). Строка начинается и кончается словами, либо является одним словом. В строке содержится по крайней мере одно слово.
Известно, что любое слово входной последоватьности имеет длину не больше K.

На стандартный поток вывода напечатайте результат описанного выше преобразования. Каждую выходную строку следует завершать символом перевода строки '\n'.
*/

void solve(int k, char* arr)
{
    int len = 0, gaps = 0;
    while (arr[len] != '\0')
    {
        if (arr[len] == ' ') { gaps++; }
        len++;
    }
    if (!gaps)
    {
        printf("%s", arr);
        for (int i = 0; i < k - len; i++)
        {
            printf(" ");
        }
        printf("\n");
        return;
    }
    int toAll = (k - len) / gaps, toSome = (k - len) % gaps;
    for (int i = 0; i < len; i++)
    {
        printf("%c", arr[i]);
        if (arr[i] == ' ')
        {
            for (int j = 0; j < toAll; j++)
            {
                printf(" ");
            }
            if (toSome)
            {
                printf(" ");
                toSome--;
            }
        }
    }
    printf("\n");
}

int main(int argc, char** argv)
{
    
    int k;
    scanf("%d\n", &k);
    char tempBuf[5];
    char* arr = (char*)malloc(2000005 * sizeof(char));
    int lenAll = 0;
    while (1)
    {
        char *buf = (char*)malloc(1000005 * sizeof(char));
        int bufI = 0, flag = 0;
        
        while (1)
        {
            fgets(tempBuf, 2, stdin);
            if (tempBuf[0] != ' ' && tempBuf[0] != '\n')
            {
                buf[bufI++] = tempBuf[0];
            }
            else
            {
                if (tempBuf[0] == '\n') { flag = 1; }
                break;
            }
        }
        buf[bufI] = '\0';
        int tempLen = bufI;
        if (lenAll == 0)
        {
            for (int i = 0; i < tempLen; i++)
            {
                arr[i] = buf[i];
            }
            arr[tempLen] = '\0';
            lenAll = tempLen;
        }
        else if (lenAll + tempLen + 1 <= k)
        {
            arr[lenAll++] = ' ';
            for (int i = lenAll; i < lenAll + tempLen; i++)
            {
                arr[i] = buf[i - lenAll];
            }
            lenAll += tempLen;
            arr[lenAll] = '\0';
        }
        else
        {
            solve(k, arr);
            for (int i = 0; i < tempLen; i++)
            {
                arr[i] = buf[i];
            }
            arr[tempLen] = '\0';
            lenAll = tempLen;
        }
        free(buf);
        if (flag)
        {
            solve(k, arr);
            free(arr);
            break;
        }
    }
    
    return 0;
}
