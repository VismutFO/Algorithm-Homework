#define _CRT_SECURE_NO_WARNINGS
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

/*
Задача 06-19: Декодирование
Вы только что получили очень важное послание, но оно закодировано алфавитным кодированием с использованием префиксного кода. Вам необходимо написать программу,
которая раскодирует его.

Алфавитным называется кодирование, при котором каждому символу исходного алфавита A (с помощью которого записано исходное сообщение) ставится в соответствие последовательность
символов кодирующего алфавита B (которым записано закодированное сообщение). Данные последовательности называются кодирующими. Кодирование сообщения сводится к замене каждого
символа исходного сообщения на соответствующую ему последовательность.

Рассмотрим пример такого кодирования. Пусть алфавит A = {a, b, c}, алфавит B = {0, 1}, а используемый код описывается соответствием a → 11, b → 010, c → 001. Тогда сообщение
aababbc будет закодировано последовательностью 111101011010010001. Если в ней расставить пробелы между подпоследовательностями, соответствующими символам, для наглядности,
то получится 11 11 010 11 010 010 001.

Код называется преффиксным, если никакая кодирующая последовательность не является преффиксом другой кодирующей последовательности. Рассмотреный выше код является 
преффиксным, а вот код a → 11, b → 110, c → 001 таковым не является, поскольку последовательность, кодирующая символ a является преффиксом последовательности, кодирующей 
символ b. Заметим, что сообщение, закодированное преффиксным кодом, всегда может быть декодировано однозначно.

В полученном сообщении символы исходного текста закодированы различными последовательностями бит. Таким образом исходный алфавит состоит из 256 различных однобайтовых
символов, а кодирующий из битов 0 и 1.

Полученное сообщение можно разбить на две части: заговоловок, состоящий из K записей, и само закодированное сообщение. Каждая из записей заголовка описывает,
какой последовательностью бит кодируется некоторый символ. Отправитель мог не включать в заголовок описание символов, которые не встречались в кодируемом сообщении, 
поэтому K может быть меньше 256. Гарантируется, что все символы, встречающиеся в сообщении представлены в заголовке.
*/

typedef long long ll;

struct node
{
	short end;//-1, если не конец, иначе в [0, 255]
	struct node* next[2];
};

struct node* init(void)
{
	struct node* newNode = (struct node*)malloc(sizeof(struct node));
	newNode->end = -1;
	newNode->next[0] = NULL;
	newNode->next[1] = NULL;
	return newNode;
}

void getNewElement(struct node **root, FILE *input)
{
	struct node **cur = root;
	uint8_t sym;
	fread(&sym, 1, 1, input);
	uint8_t len;
	fread(&len, 1, 1, input);
	for (size_t byte = 0; byte < len; byte += 8)
	{
		uint8_t temp;
		fread(&temp, 1, 1, input);
		for (size_t j = 0; j < 8 && byte + j < len; j++)
		{
			int ifik = (temp & (1 << j)) == 0 ? 0 : 1;
			if ((*cur)->next[ifik] == NULL) { (*cur)->next[ifik] = init(); }
			cur = &(*cur)->next[ifik];
		}
	}
	(*cur)->end = sym;
	return;
}

int main(int argc, char** argv)
{
	FILE* input, * output;
	input = fopen("crypto", "rb"), output = fopen("text", "wb");
	struct node* root = init();
	uint8_t k;
	fread(&k, 1, 1, input);
	if (k == 0) { for (size_t i = 0; i < 256; i++) { getNewElement(&root, input); } }
	else { for (size_t i = 0; i < k; i++) { getNewElement(&root, input); } }
	struct node* cur = root;
	uint8_t c;
	while (fread(&c, 1, 1, input) == 1)
	{
		//printf("%04x:%02x ", ftell(input), c);
		for (int j = 0; j < 8; j++)
		{
			int ifik = ((c & (1 << j)) == 0 ? 0 : 1);
			if (cur->next[ifik] == NULL)
			{
				fclose(input);
				fclose(output);
				return 0;
			}
			cur = cur->next[ifik];
			if (cur->end != -1)
			{
				uint8_t temp2 = (uint8_t)cur->end;
				fwrite(&temp2, 1, 1, output);
				//printf(".");
				cur = root;
			}
		}
	}
	fclose(input);
	fclose(output);
	return 0;
}
